module forwarding_checker
  (
    input logic 	 reset,
    input logic 	 clk,

    input logic 	 id_ex_flush_i,
    input logic 	 stall,
    input logic [31 : 0] alu_result_mem_i,
    input logic [31 : 0] alu_in_a_i,
    input logic [31 : 0] alu_in_b_i,

    input logic [4 : 0]  rs1_address_id_i,
    input logic [4 : 0]  rs2_address_id_i,

   
    input logic [6 : 0]  opcode_id_i,
    input logic 	 reg_write_i,
    input logic [4 : 0]  rd_address_mem_i
 
);   

   
   logic 		 alu_forward_a_check;
   logic 		 opcode_check;
   logic [4 : 0] 	 rs1_address_ex_r;
   logic [4 : 0] 	 rs2_address_ex_r;
   logic [6 : 0] 	 opcode_ex_r, opcode_mem_r; 	 
   
   typedef enum 	 logic[3:0]{7'b0000011, 7'b0100011. 7'b0110011, 7'b0010011, 7'b1100011, 7'b1100111, 7'b0010111, 7'b0110111} states;
   
   always @(posedge clk)begin
      if(!reset)begin
	 rs1_address_ex_r <= 0;
	 rs2_address_ex_r <= 0;
	 opcode_ex_r <= 0;
	 opcode_mem_r <= 0;
      end
      else begin
	 if (!stall)begin
	    rs1_address_ex_r <= rs1_address_id_i;
	    rs2_address_ex_r <= rs2_address_id_i;
	    opcode_ex_r <= opcode_id_i;
	    opcode_mem_r <= opcode_ex_r;
	 end
      end  
   end // always @ (posedge clk)

   default clocking @(posedge clk); endclocking
   default disable iff !reset;
   

   
   assign alu_forward_a_check = $past(rs1_address_ex_r) == $past(rd_address_mem_i) && reg_write_i && $past(rd_address_mem_i) != 0;
   // check to see if instruction in mem is not conditional branch or store instruction.
   //Thats because they are the only two instructions that dont mess with rd
   //Also check if in ex phase is an R type instruction
   assign opcode_check = $past(opcode_ex_r) == 7'b0110011;   
   
   opcode_contraint: assume property ()
   alu_forward_assert: assert property (alu_forward_a_check && opcode_check |-> $past(alu_result_mem_i) == $past(alu_in_a_i));
   
   

endmodule
